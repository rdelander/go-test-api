// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: addresses.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAddress = `-- name: CreateAddress :one
INSERT INTO addresses (
    entity_type, entity_id, address_type,
    street_line1, street_line2, city, state, postal_code, country,
    created_at, updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, entity_type, entity_id, address_type, street_line1, street_line2, 
    city, state, postal_code, country, created_at, updated_at
`

type CreateAddressParams struct {
	EntityType  EntityType         `json:"entity_type"`
	EntityID    int32              `json:"entity_id"`
	AddressType AddressType        `json:"address_type"`
	StreetLine1 string             `json:"street_line1"`
	StreetLine2 pgtype.Text        `json:"street_line2"`
	City        string             `json:"city"`
	State       string             `json:"state"`
	PostalCode  string             `json:"postal_code"`
	Country     string             `json:"country"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateAddress(ctx context.Context, arg CreateAddressParams) (Address, error) {
	row := q.db.QueryRow(ctx, createAddress,
		arg.EntityType,
		arg.EntityID,
		arg.AddressType,
		arg.StreetLine1,
		arg.StreetLine2,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.EntityID,
		&i.AddressType,
		&i.StreetLine1,
		&i.StreetLine2,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAddress = `-- name: DeleteAddress :exec
DELETE FROM addresses
WHERE id = $1
`

func (q *Queries) DeleteAddress(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteAddress, id)
	return err
}

const getAddress = `-- name: GetAddress :one
SELECT id, entity_type, entity_id, address_type, street_line1, street_line2, 
    city, state, postal_code, country, created_at, updated_at
FROM addresses
WHERE id = $1
`

func (q *Queries) GetAddress(ctx context.Context, id int32) (Address, error) {
	row := q.db.QueryRow(ctx, getAddress, id)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.EntityID,
		&i.AddressType,
		&i.StreetLine1,
		&i.StreetLine2,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAddressesByEntity = `-- name: ListAddressesByEntity :many
SELECT id, entity_type, entity_id, address_type, street_line1, street_line2, 
    city, state, postal_code, country, created_at, updated_at
FROM addresses
WHERE entity_type = $1 AND entity_id = $2
ORDER BY address_type, id
`

type ListAddressesByEntityParams struct {
	EntityType EntityType `json:"entity_type"`
	EntityID   int32      `json:"entity_id"`
}

func (q *Queries) ListAddressesByEntity(ctx context.Context, arg ListAddressesByEntityParams) ([]Address, error) {
	rows, err := q.db.Query(ctx, listAddressesByEntity, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Address{}
	for rows.Next() {
		var i Address
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.AddressType,
			&i.StreetLine1,
			&i.StreetLine2,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAddressesByEntityAndType = `-- name: ListAddressesByEntityAndType :many
SELECT id, entity_type, entity_id, address_type, street_line1, street_line2, 
    city, state, postal_code, country, created_at, updated_at
FROM addresses
WHERE entity_type = $1 AND entity_id = $2 AND address_type = $3
ORDER BY id
`

type ListAddressesByEntityAndTypeParams struct {
	EntityType  EntityType  `json:"entity_type"`
	EntityID    int32       `json:"entity_id"`
	AddressType AddressType `json:"address_type"`
}

func (q *Queries) ListAddressesByEntityAndType(ctx context.Context, arg ListAddressesByEntityAndTypeParams) ([]Address, error) {
	rows, err := q.db.Query(ctx, listAddressesByEntityAndType, arg.EntityType, arg.EntityID, arg.AddressType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Address{}
	for rows.Next() {
		var i Address
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.AddressType,
			&i.StreetLine1,
			&i.StreetLine2,
			&i.City,
			&i.State,
			&i.PostalCode,
			&i.Country,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAddress = `-- name: UpdateAddress :one
UPDATE addresses
SET street_line1 = $2,
    street_line2 = $3,
    city = $4,
    state = $5,
    postal_code = $6,
    country = $7,
    updated_at = $8
WHERE id = $1
RETURNING id, entity_type, entity_id, address_type, street_line1, street_line2, 
    city, state, postal_code, country, created_at, updated_at
`

type UpdateAddressParams struct {
	ID          int32              `json:"id"`
	StreetLine1 string             `json:"street_line1"`
	StreetLine2 pgtype.Text        `json:"street_line2"`
	City        string             `json:"city"`
	State       string             `json:"state"`
	PostalCode  string             `json:"postal_code"`
	Country     string             `json:"country"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateAddress(ctx context.Context, arg UpdateAddressParams) (Address, error) {
	row := q.db.QueryRow(ctx, updateAddress,
		arg.ID,
		arg.StreetLine1,
		arg.StreetLine2,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.UpdatedAt,
	)
	var i Address
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.EntityID,
		&i.AddressType,
		&i.StreetLine1,
		&i.StreetLine2,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
